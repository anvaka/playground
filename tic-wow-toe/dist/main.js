(()=>{var __webpack_modules__={245:module=>{eval("module.exports = function eventify(subject) {\n  validateSubject(subject);\n\n  var eventsStorage = createEventsStorage(subject);\n  subject.on = eventsStorage.on;\n  subject.off = eventsStorage.off;\n  subject.fire = eventsStorage.fire;\n  return subject;\n};\n\nfunction createEventsStorage(subject) {\n  // Store all event listeners to this hash. Key is event name, value is array\n  // of callback records.\n  //\n  // A callback record consists of callback function and its optional context:\n  // { 'eventName' => [{callback: function, ctx: object}] }\n  var registeredEvents = Object.create(null);\n\n  return {\n    on: function (eventName, callback, ctx) {\n      if (typeof callback !== 'function') {\n        throw new Error('callback is expected to be a function');\n      }\n      var handlers = registeredEvents[eventName];\n      if (!handlers) {\n        handlers = registeredEvents[eventName] = [];\n      }\n      handlers.push({callback: callback, ctx: ctx});\n\n      return subject;\n    },\n\n    off: function (eventName, callback) {\n      var wantToRemoveAll = (typeof eventName === 'undefined');\n      if (wantToRemoveAll) {\n        // Killing old events storage should be enough in this case:\n        registeredEvents = Object.create(null);\n        return subject;\n      }\n\n      if (registeredEvents[eventName]) {\n        var deleteAllCallbacksForEvent = (typeof callback !== 'function');\n        if (deleteAllCallbacksForEvent) {\n          delete registeredEvents[eventName];\n        } else {\n          var callbacks = registeredEvents[eventName];\n          for (var i = 0; i < callbacks.length; ++i) {\n            if (callbacks[i].callback === callback) {\n              callbacks.splice(i, 1);\n            }\n          }\n        }\n      }\n\n      return subject;\n    },\n\n    fire: function (eventName) {\n      var callbacks = registeredEvents[eventName];\n      if (!callbacks) {\n        return subject;\n      }\n\n      var fireArguments;\n      if (arguments.length > 1) {\n        fireArguments = Array.prototype.splice.call(arguments, 1);\n      }\n      for(var i = 0; i < callbacks.length; ++i) {\n        var callbackInfo = callbacks[i];\n        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n      }\n\n      return subject;\n    }\n  };\n}\n\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('Eventify cannot use falsy object as events subject');\n  }\n  var reservedWords = ['on', 'fire', 'off'];\n  for (var i = 0; i < reservedWords.length; ++i) {\n    if (subject.hasOwnProperty(reservedWords[i])) {\n      throw new Error(\"Subject cannot be eventified, since it already has property '\" + reservedWords[i] + \"'\");\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ngraph.events/index.js?")},161:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/**\n * Allows application to access and update current app state via query string\n */\nmodule.exports = queryState;\n\nvar eventify = __webpack_require__(40);\nvar windowHistory = __webpack_require__(669);\n\n/**\n * Just a convenience function that returns singleton instance of a query state\n */\nqueryState.instance = instance;\n\n// this variable holds singleton instance of the query state\nvar singletonQS;\n\n/**\n * Creates new instance of the query state.\n */\nfunction queryState(defaults, options) {\n  options = options || {};\n  var history = options.history || windowHistory(defaults, options);\n  validateHistoryAPI(history);\n\n  history.onChanged(updateQuery)\n\n  var query = history.get() || Object.create(null);\n\n  var api = {\n\n    /**\n     * Gets current state.\n     *\n     * @param {string?} keyName if present then value for this key is returned.\n     * Otherwise the entire app state is returned.\n     */\n    get: getValue,\n\n    /**\n     * Merges current app state with new key/value.\n     *\n     * @param {string} key name\n     * @param {string|number|date} value\n     */\n    set: setValue,\n\n    /**\n     * Removes value from the query string\n     */\n    unset: unsetValue,\n\n    /**\n     * Similar to `set()`, but only sets value if it was not set before.\n     *\n     * @param {string} key name\n     * @param {string|number|date} value\n     */\n    setIfEmpty: setIfEmpty,\n\n    /**\n     * Releases all resources acquired by query state. After calling this method\n     * no hash monitoring will happen and no more events will be fired.\n     */\n    dispose: dispose,\n\n    onChange: onChange,\n    offChange: offChange,\n\n    getHistoryObject: getHistoryObject,\n  }\n\n  var eventBus = eventify({});\n\n  return api;\n\n  function onChange(callback, ctx) {\n    eventBus.on('change', callback, ctx);\n  }\n\n  function offChange(callback, ctx) {\n    eventBus.off('change', callback, ctx)\n  }\n\n  function getHistoryObject() {\n    return history;\n  }\n\n  function dispose() {\n    // dispose all history listeners\n    history.dispose();\n\n    // And remove our own listeners\n    eventBus.off();\n  }\n\n  function getValue(keyName) {\n    if (keyName === undefined) return query;\n\n    return query[keyName];\n  }\n\n  function setValue(keyName, value) {\n    var keyNameType = typeof keyName;\n\n    if (keyNameType === 'object') {\n      Object.keys(keyName).forEach(function(key) {\n        query[key] = keyName[key];\n      });\n    } else if (keyNameType === 'string') {\n      query[keyName] = value;\n    }\n\n    history.set(query);\n\n    return api;\n  }\n\n  function unsetValue(keyName) {\n    if (!(keyName in query)) return; // nothing to do\n\n    delete query[keyName];\n    history.set(query);\n\n    return api;\n  }\n\n  function updateQuery(newAppState) {\n    query = newAppState;\n    eventBus.fire('change', query);\n  }\n\n  function setIfEmpty(keyName, value) {\n    if (typeof keyName === 'object') {\n      Object.keys(keyName).forEach(function(key) {\n        // TODO: Can I remove code duplication? The main reason why I don't\n        // want recursion here is to avoid spamming `history.set()`\n        if (key in query) return; // key name is not empty\n\n        query[key] = keyName[key];\n      });\n    }\n\n    if (keyName in query) return; // key name is not empty\n    query[keyName] = value;\n\n    history.set(query);\n\n    return api;\n  }\n}\n\n/**\n * Returns singleton instance of the query state.\n *\n * @param {Object} defaults - if present, then it is passed to the current instance\n * of the query state. Defaults are applied only if they were not present before.\n */\nfunction instance(defaults, options) {\n  if (!singletonQS) {\n    singletonQS = queryState(defaults, options);\n  } else if (defaults) {\n    singletonQS.setIfEmpty(defaults);\n  }\n\n  return singletonQS;\n}\n\nfunction validateHistoryAPI(history) {\n  if (!history) throw new Error('history is required');\n  if (typeof history.dispose !== 'function') throw new Error('dispose is required');\n  if (typeof history.onChanged !== 'function') throw new Error('onChanged is required');\n}\n\n\n//# sourceURL=webpack:///./node_modules/query-state/index.js?")},827:module=>{eval("/**\n * Provides a `null` object that matches history API\n */\nmodule.exports = inMemoryHistory;\n\nfunction inMemoryHistory(defaults) {\n  var listeners = [];\n  var lastQueryObject = defaults;\n\n  return {\n    dispose: dispose,\n    onChanged: onChanged,\n    set: set,\n    get: get\n  };\n\n  function get() {\n    return lastQueryObject;\n  }\n\n  function set(newQueryObject) {\n    lastQueryObject = newQueryObject;\n    setTimeout(function() {\n      triggerChange(newQueryObject);\n    }, 0);\n  }\n\n  function dispose() {\n    listeners = [];\n  }\n\n  function onChanged(changeCallback) {\n    if (typeof changeCallback !== 'function') {\n      throw new Error('changeCallback should be a function')\n    }\n\n    listeners.push(changeCallback);\n  }\n\n  function triggerChange(appState) {\n    listeners.forEach(function(listener) {\n      listener(appState);\n    });\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/query-state/lib/inMemoryHistory.js?")},513:module=>{eval("/**\n * This module is similar to JSON, but it encodes/decodes in query string\n * format `key1=value1...`\n */\nmodule.exports = {\n  parse: parse,\n  stringify: stringify\n};\n\nfunction stringify(object) {\n  if (!object) return '';\n\n  return Object.keys(object).map(toPairs).join('&');\n\n  function toPairs(key) {\n    var value = object[key];\n    var pair = encodePart(key);\n    if (value !== undefined) {\n      pair += '=' + encodeValue(value);\n    }\n\n    return pair;\n  }\n}\n\nfunction parse(queryString) {\n  var query = Object.create(null);\n\n  if (!queryString) return query;\n\n  queryString.split('&').forEach(decodeRecord);\n\n  return query;\n\n  function decodeRecord(queryRecord) {\n    if (!queryRecord) return;\n\n    var pair = queryRecord.split('=');\n    query[decodeURIComponent(pair[0])] = decodeValue(pair[1]);\n  }\n}\n\nfunction encodeValue(value) {\n  // TODO: Do I need this?\n  // if (typeof value === 'string') {\n  //   if (value.match(/^(true|false)$/)) {\n  //     // special handling of strings that look like booleans\n  //     value = JSON.stringify('' + value);\n  //   } else if (value.match(/^-?\\d+\\.?\\d*$/)) {\n  //     // special handling of strings that look like numbers\n  //     value = JSON.stringify('' + value);\n  //   }\n  // }\n  if (value instanceof Date) {\n    value = value.toISOString();\n  }\n  var uriValue = encodePart(value);\n  return uriValue;\n}\n\nfunction encodePart(part) {\n  // We want to make sure that we also encode symbols like ( and ) correctly\n  var encoded = encodeURIComponent(part);\n  return encoded.replace(/[()]/g, saferEscape);\n}\n\nfunction saferEscape(character) {\n  if (character === ')') return '%29';\n  if (character === '(') return '%28';\n  return character; // What?\n}\n\n/**\n * This method returns typed value from string\n */\nfunction decodeValue(value) {\n  value = decodeURIComponent(value);\n\n  if (value === \"\") return value;\n  if (!isNaN(value)) return parseFloat(value);\n  if (isBolean(value)) return value === 'true';\n  if (isISODateString(value)) return new Date(value);\n\n  return value;\n}\n\nfunction isBolean(strValue) {\n  return strValue === 'true' || strValue === 'false';\n}\n\nfunction isISODateString(str) {\n  return str && str.match(/(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/)\n}\n\n\n//# sourceURL=webpack:///./node_modules/query-state/lib/query.js?")},669:(module,__unused_webpack_exports,__webpack_require__)=>{eval("/**\n * Uses `window` to monitor hash and update hash\n */\nmodule.exports = windowHistory;\n\nvar inMemoryHistory = __webpack_require__(827);\nvar query = __webpack_require__(513);\n\nfunction windowHistory(defaults, options) {\n  // If we don't support window, we are probably running in node. Just return\n  // in memory history\n  if (typeof window === 'undefined') return inMemoryHistory(defaults);\n\n  // Store all `onChanged()` listeners here, so that we can have just one\n  // `hashchange` listener, and notify one listeners within single event.\n  var listeners = [];\n\n  var useSearchPart = options && options.useSearch; // prefer query ? over hash #\n\n  // This prefix is used for all query strings. So our state is stored as\n  // my-app.com/#?key=value\n  var hashPrefix = useSearchPart ? '?' : '#?';\n\n  if (options.rewriteHashToSearch) {\n    rewriteHashToSearch();\n  }\n  init();\n\n  // This is our public API:\n  return {\n    /**\n     * Adds callback that is called when hash change happen. Callback receives\n     * current hash string with `#?` sign\n     * \n     * @param {Function} changeCallback - a function that is called when hash is\n     * changed. Callback gets one argument that represents the new state.\n     */\n    onChanged: onChanged,\n\n    /**\n     * Releases all resources\n     */\n    dispose: dispose,\n\n    /**\n     * Sets a new app state\n     *\n     * @param {object} appState - the new application state, that should be\n     * persisted in the hash string\n     */\n    set: set,\n\n    /**\n     * Gets current app state\n     */\n    get: getStateFromHash,\n\n    /**\n     * Allows to rewrite current hash url into search url\n     */\n    rewriteHashToSearch: rewriteHashToSearch\n  };\n\n  // Public API is over. You can ignore this part.\n\n  function init() {\n    var stateFromHash = getStateFromHash();\n    var stateChanged = false;\n\n    if (typeof defaults === 'object' && defaults) {\n      Object.keys(defaults).forEach(function(key) {\n        if (key in stateFromHash) return;\n\n        stateFromHash[key] = defaults[key]\n        stateChanged = true;\n      });\n    }\n\n    if (stateChanged) set(stateFromHash);\n  }\n\n  function rewriteHashToSearch() {\n    var mergedState = Object.create(null);\n\n    var searchString = window.location.search;\n    if (searchString) mergedState = Object.assign(mergedState, query.parse(searchString.substr(1)));\n\n    var hashString = window.location.hash;\n    if (hashString) mergedState = Object.assign(mergedState, query.parse(hashString.substr(2)));\n\n    set(mergedState);\n  }\n\n  function set(appState) {\n    var hash = hashPrefix + query.stringify(appState);\n    if (useSearchPart && window.location.hash) {\n      // preserve hash if it was there.\n      hash += window.location.hash;\n    }\n\n    if (window.history) {\n      window.history.replaceState(undefined, undefined, hash);\n    } else {\n      window.location.replace(hash);\n    }\n  }\n\n  function onChanged(changeCallback) {\n    if (typeof changeCallback !== 'function') throw new Error('changeCallback needs to be a function');\n\n    // we start listen just once, only if we didn't listen before:\n    if (listeners.length === 0) {\n      window.addEventListener('hashchange', onHashChanged, false);\n    }\n\n    listeners.push(changeCallback);\n  }\n\n  function dispose() {\n    if (listeners.length === 0) return; // no need to do anything.\n\n    // Let garbage collector collect all listeners;\n    listeners = [];\n\n    // And release hash change event:\n    window.removeEventListener('hashchange', onHashChanged, false);\n  }\n\n  function onHashChanged() {\n    var appState = getStateFromHash();\n    notifyListeners(appState);\n  }\n\n  function notifyListeners(appState) {\n    for (var i = 0; i < listeners.length; ++i) {\n      var listener = listeners[i];\n      listener(appState);\n    }\n  }\n\n  function getStateFromHash() {\n    var baseString = useSearchPart ? window.location.search : window.location.hash;\n    // or symbol || is used to get empty string when no base string is present. \n    var queryString = (baseString || hashPrefix).substr(hashPrefix.length);\n    return query.parse(queryString);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/query-state/lib/windowHistory.js?")},40:module=>{eval("module.exports = function(subject) {\n  validateSubject(subject);\n\n  var eventsStorage = createEventsStorage(subject);\n  subject.on = eventsStorage.on;\n  subject.off = eventsStorage.off;\n  subject.fire = eventsStorage.fire;\n  return subject;\n};\n\nfunction createEventsStorage(subject) {\n  // Store all event listeners to this hash. Key is event name, value is array\n  // of callback records.\n  //\n  // A callback record consists of callback function and its optional context:\n  // { 'eventName' => [{callback: function, ctx: object}] }\n  var registeredEvents = Object.create(null);\n\n  return {\n    on: function (eventName, callback, ctx) {\n      if (typeof callback !== 'function') {\n        throw new Error('callback is expected to be a function');\n      }\n      var handlers = registeredEvents[eventName];\n      if (!handlers) {\n        handlers = registeredEvents[eventName] = [];\n      }\n      handlers.push({callback: callback, ctx: ctx});\n\n      return subject;\n    },\n\n    off: function (eventName, callback) {\n      var wantToRemoveAll = (typeof eventName === 'undefined');\n      if (wantToRemoveAll) {\n        // Killing old events storage should be enough in this case:\n        registeredEvents = Object.create(null);\n        return subject;\n      }\n\n      if (registeredEvents[eventName]) {\n        var deleteAllCallbacksForEvent = (typeof callback !== 'function');\n        if (deleteAllCallbacksForEvent) {\n          delete registeredEvents[eventName];\n        } else {\n          var callbacks = registeredEvents[eventName];\n          for (var i = 0; i < callbacks.length; ++i) {\n            if (callbacks[i].callback === callback) {\n              callbacks.splice(i, 1);\n            }\n          }\n        }\n      }\n\n      return subject;\n    },\n\n    fire: function (eventName) {\n      var callbacks = registeredEvents[eventName];\n      if (!callbacks) {\n        return subject;\n      }\n\n      var fireArguments;\n      if (arguments.length > 1) {\n        fireArguments = Array.prototype.splice.call(arguments, 1);\n      }\n      for(var i = 0; i < callbacks.length; ++i) {\n        var callbackInfo = callbacks[i];\n        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n      }\n\n      return subject;\n    }\n  };\n}\n\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('Eventify cannot use falsy object as events subject');\n  }\n  var reservedWords = ['on', 'fire', 'off'];\n  for (var i = 0; i < reservedWords.length; ++i) {\n    if (subject.hasOwnProperty(reservedWords[i])) {\n      throw new Error(\"Subject cannot be eventified, since it already has property '\" + reservedWords[i] + \"'\");\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/query-state/node_modules/ngraph.events/index.js?")},411:(__unused_webpack___webpack_module__,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXTERNAL MODULE: ./node_modules/query-state/index.js\nvar query_state = __webpack_require__(161);\n// EXTERNAL MODULE: ./node_modules/ngraph.events/index.js\nvar ngraph_events = __webpack_require__(245);\n;// CONCATENATED MODULE: ./src/GameBoard.js\n\n\nclass Position {\n  constructor(x, y, symbol) {\n    this.x = x;\n    this.y = y;\n    this.symbol = symbol;\n    this.lDiagonalChecked = false;\n    this.rDiagonalChecked = false;\n    this.horizontalChecked = false;\n    this.verticalChecked = false;\n  }\n\n  clean() {\n    this.lDiagonalChecked = false;\n    this.rDiagonalChecked = false;\n    this.horizontalChecked = false;\n    this.verticalChecked = false;\n  }\n}\n\nclass GameBoard {\n  constructor(width, height, winLength = 5, playerSymbols = 'XO') {\n    this.width = width;\n    this.height = height;\n    this.winLength = winLength;\n    this.positions = [];\n    this.lookup = Object.create(null);\n    this.playerSymbols = [...playerSymbols];\n    this.currentPlayer = 0;\n    ngraph_events(this);\n  }\n\n  play(x, y, symbol) {\n    if (x < 0 || x >= this.width || y < 0 || y >= this.height) {\n      throw new Error(`Invalid position ${x}, ${y}`);\n    }\n\n    if (this.getPosition(x, y)) {\n      // Position is already taken\n      return false;\n    }\n\n    if (!symbol) {\n      symbol = this.playerSymbols[this.currentPlayer];\n      this.currentPlayer = (this.currentPlayer + 1) % this.playerSymbols.length;\n    }\n\n    const pos = new Position(x, y, symbol);\n\n    let row = this.lookup[y];\n    if (!row) this.lookup[y] = row = {};\n    let col = row[x];\n    if (col) {\n      throw new Error(`Position ${x}, ${y} is already occupied`);\n    }\n    row[x] = pos;\n    this.positions.push(pos);\n    this.fire('play');\n\n    return true;\n  }\n\n  clear() {\n    this.positions = [];\n    this.lookup = Object.create(null);\n    this.fire('clear');\n  }\n\n  nextMoveSymbol() {\n    return this.playerSymbols[this.currentPlayer];\n  }\n\n  getPosition(x, y) {\n    let row = this.lookup[y];\n    if (!row) return;\n    return row[x];\n  }\n\n  getWinner() {\n    this.cleanWinnerCheck();\n    for (let pos of this.positions) {\n      let sequence = \n        filterWinner(getLongestSequence(pos, this, -1, 0, 1, 0, 'horizontalChecked'), this.winLength) ||\n        filterWinner(getLongestSequence(pos, this, 0, -1,  0, 1, 'verticalChecked'), this.winLength) ||\n        filterWinner(getLongestSequence(pos, this, -1, -1, 1, 1, 'lDiagonalChecked'), this.winLength) ||\n        filterWinner(getLongestSequence(pos, this, -1,  1, 1, -1, 'rDiagonalChecked'), this.winLength);\n      if (sequence) {\n        return {\n          symbol: this.getPosition(sequence[0][0], sequence[0][1]).symbol,\n          sequence\n        }\n      }\n    }\n  }\n\n  cleanWinnerCheck() {\n    this.positions.forEach(pos => {\n      pos.clean();\n    });\n  }\n}\n\nfunction getLongestSequence(pos, board, leftDx, leftDy, rightDx, rightDy, checkName) {\n  if (pos[checkName]) return; // already checked\n\n  let minLeft = pos.x;\n  let minTop = pos.y;\n\n  let leftSymbol = board.getPosition(minLeft + leftDx, minTop + leftDy);\n  pos[checkName] = true;\n\n  while (leftSymbol && leftSymbol.symbol === pos.symbol) {\n    minLeft += leftDx;\n    minTop += leftDy;\n\n    leftSymbol[checkName] = true;\n    leftSymbol = board.getPosition(minLeft + leftDx, minTop + leftDy);\n  }\n\n  let maxRight = pos.x;\n  let maxBottom = pos.y;\n  let rightSymbol = board.getPosition(pos.x + rightDx, pos.y + rightDy);\n  while (rightSymbol && rightSymbol.symbol === pos.symbol) {\n    maxRight += rightDx;\n    maxBottom += rightDy;\n    rightSymbol[checkName] = true;\n    rightSymbol = board.getPosition(maxRight + rightDx, maxBottom + rightDy);\n  }\n\n  return {minLeft, minTop, maxRight, maxBottom, dx: rightDx, dy: rightDy};\n}\n\nfunction filterWinner(boundingBox, consequentSymbolCountToWin) {\n  if (!boundingBox) return; // No winner here.\n\n  let {minLeft, minTop, maxRight, maxBottom, dx, dy} = boundingBox;\n\n  let count = 0;\n  let winner = [];\n  let ySign = maxBottom > minTop ? 1 : -1;\n  let x = minLeft; let y = minTop;\n  while (x != maxRight || y != maxBottom) {\n    winner.push([x, y]);\n    x += dx;\n    y += dy;\n  }\n  if (minLeft !== maxRight || minTop !== maxBottom) {\n    winner.push([maxRight, maxBottom]);\n  }\n  if (winner.length >= consequentSymbolCountToWin) {\n    return winner;\n  }\n}\n;// CONCATENATED MODULE: ./src/HTMLBoardInputHandler.js\nclass GameCursor {\n  constructor(board) {\n    this.board = board;\n\n    const cursor = document.createElement('div');\n    cursor.className = 'cursor';\n    cursor.style.position = 'absolute';\n    cursor.style.width = (board.cellSize - 1) + 'px';\n    cursor.style.height = (board.cellSize - 1)+ 'px';\n    board.container.appendChild(cursor);\n\n    this.cursor = cursor;\n    this.renderAt(0, 0);\n  }\n\n  renderAt(cellX, cellY) {\n    cellX = clamp(cellX, 0, this.board.board.width - 1);\n    cellY = clamp(cellY, 0, this.board.board.height - 1);\n    this.lastX = cellX;\n    this.lastY = cellY;\n    this.cursor.style.left = (cellX * this.board.cellSize + 1) + 'px';\n    this.cursor.style.top =  (cellY * this.board.cellSize + 1) + 'px';\n  }\n}\n\nclass HTMLBoardInputHandler {\n  constructor(gameBoard) {\n    this.gameBoard = gameBoard;\n\n    this.onMouseMove = this.onMouseMove.bind(this);\n    this.onClick = this.onClick.bind(this);\n    this.onKeyDown = this.onKeyDown.bind(this);\n\n    const {container} =  this.gameBoard;\n    container.focus();\n    container.addEventListener('mousemove', this.onMouseMove);\n    container.addEventListener('click', this.onClick);\n    window.addEventListener('keydown', this.onKeyDown);\n\n    this.gameCursor = new GameCursor(gameBoard);\n  }\n\n  dispose() {\n    this.gameBoard.container.removeEventListener('mousemove', this.onMouseMove);\n    this.gameBoard.container.removeEventListener('click', this.onClick);\n    window.removeEventListener('keydown', this.onKeyDown);\n  }\n\n  onKeyDown(e) {\n    if (e.keyCode === 32) { // space\n      this.gameBoard.play(this.gameCursor.lastX, this.gameCursor.lastY);\n    } else if (e.keyCode === 37) { // left\n      this.gameCursor.renderAt(this.gameCursor.lastX - 1, this.gameCursor.lastY);\n    } else if (e.keyCode === 38) { // up\n      this.gameCursor.renderAt(this.gameCursor.lastX, this.gameCursor.lastY - 1);\n    } else if (e.keyCode === 39) { // right\n      this.gameCursor.renderAt(this.gameCursor.lastX + 1, this.gameCursor.lastY);\n    } else if (e.keyCode === 40) { // down\n      this.gameCursor.renderAt(this.gameCursor.lastX, this.gameCursor.lastY + 1);\n    }\n  }\n\n  onMouseMove(e) {\n    let { x, y } = this.getCellPosition(e);\n    this.gameCursor.renderAt(x, y);\n  }\n\n  onClick(e) {\n    let { x, y } = this.getCellPosition(e);\n    this.gameBoard.play(x, y);\n  }\n\n  getCellPosition(e) {\n    let rect = e.target.getBoundingClientRect();\n    let x = e.clientX - rect.left;\n    let y = e.clientY - rect.top;\n    let cellX = clamp(Math.floor(x / this.gameBoard.cellSize), 0, this.gameBoard.board.width - 1);\n    let cellY = clamp(Math.floor(y / this.gameBoard.cellSize), 0, this.gameBoard.board.height - 1);\n    return { x: cellX, y: cellY };\n  }\n}\n\nfunction clamp(x, min, max) {\n  return Math.min(Math.max(x, min), max);\n}\n;// CONCATENATED MODULE: ./src/HTMLBoardRenderer.js\n\n\nclass HTMLBoardRenderer {\n  constructor(container, board) {\n    this.container = container;\n    this.board = board;\n    this.cellSize = 42;\n    this.boardColor = '#333';\n    this.renderBackground();\n\n    this.inputHandler = new HTMLBoardInputHandler(this);\n    this.renderedPositions = new Map();\n    this.renderPositions();\n    board.on('play', this.renderPositions, this);\n    board.on('clear', this.clear, this);\n    let lastMove = document.querySelector('.last-move');\n    if (lastMove) lastMove.scrollIntoView();\n  }\n\n  play(cellX, cellY) {\n    this.board.play(cellX, cellY);\n  }\n\n  renderBackground() {\n    this.container.style.width =  (1 + this.board.width  * this.cellSize) + 'px';\n    this.container.style.height = (1 + this.board.height * this.cellSize) + 'px';\n    this.container.style.backgroundSize = this.cellSize + 'px ' + this.cellSize + 'px';\n  }\n\n  clear() {\n    this.renderedPositions.forEach((positionElement) => {\n      positionElement.parentElement.removeChild(positionElement);\n    });\n    this.renderedPositions.clear();\n    this.renderPositions();\n  }\n\n  renderPositions() {\n    this.board.positions.forEach((position) => {\n      if (this.renderedPositions.get(position)) return; // already rendered;\n      let positionElement = createPositionElement(position, this.cellSize, this.container);\n      this.renderedPositions.set(position, positionElement);\n    });\n\n    let winner = this.board.getWinner();\n    if (winner) {\n      winner.sequence.forEach(([cellX, cellY]) => {\n        const position = this.board.getPosition(cellX, cellY);\n        this.renderedPositions.get(position).classList.add('winner');\n      })\n    }\n    Array.from(this.container.querySelectorAll('.last-move')).forEach(x => {\n      x.classList.remove('last-move');\n    });\n    if (this.board.positions.length > 0) {\n      let last = this.board.positions[this.board.positions.length - 1];\n      this.renderedPositions.get(last).classList.add('last-move');\n    }\n\n  }\n}\n\nfunction createPositionElement(position, size, container) {\n  let positionElement = document.createElement('div');\n  positionElement.className = 'symbol';\n  positionElement.style.width =  (size - 1) + 'px';\n  positionElement.style.height = (size - 1) + 'px';\n  positionElement.style.left = (1 + position.x * size) + 'px';\n  positionElement.style.top =  (1 + position.y * size) + 'px';\n  positionElement.style.fontSize = size + 'px';\n  positionElement.style.lineHeight = size + 'px';\n  positionElement.innerText = position.symbol;\n\n  container.appendChild(positionElement);\n  return positionElement;\n}\n;// CONCATENATED MODULE: ./src/index.js\n\n\n\n\n\nfunction createPointTransformer(svg) {\n  let p = svg.parentElement.createSVGPoint()\n\n  return function (x, y) {\n    p.x = x;\n    p.y = y;\n    return p.matrixTransform(svg.getScreenCTM().inverse());\n  }\n}\nlet qs = query_state({w: 10, h: 10, s: 'XO', l: 5, m:''}, {useSearch: true});\n\nlet width = qs.get('w');\nlet height = qs.get('h');\nlet board = new GameBoard(width, height, qs.get('l'), qs.get('s'));\nlet nextMove = document.getElementById('next-move');\n\ndocument.getElementById('in-a-row').innerText = qs.get('l');\n\ndecodeMovesSequence(qs.get('m'), width).forEach(m => {\n  try {\n    board.play(m[0], m[1])\n  } catch(e) {\n    console.error(e.message)\n  }\n});\nboard.on('play', onBoardChanged);\nboard.on('clear', onBoardChanged);\n\ndocument.querySelector('#clear').addEventListener('click', (e) => {\n  e.preventDefault();\n  board.clear();\n});\n\nrenderNextMoveSymbol();\n\nlet renderer = new HTMLBoardRenderer(document.getElementById('board'), board);\n\nfunction decodeMovesSequence(encodedSequence, w) {\n  if (encodedSequence === '') return [];\n\n  try {\n    return ('' + encodedSequence).split('_').map(encodedPoint => {\n      let absoluteAddress = Number.parseInt(encodedPoint, 36)\n      let row = Math.floor(absoluteAddress / w)\n      let col = absoluteAddress % w;\n      return [row, col];\n    });\n  } catch (e) {\n    console.error('Failed to decode sequence', e);\n    return [];\n  }\n\n}\n\nfunction onBoardChanged() {\n  updateUrl();\n  renderNextMoveSymbol();\n}\n\nfunction renderNextMoveSymbol() {\n  nextMove.innerText = board.nextMoveSymbol();\n}\n\nfunction updateUrl() {\n  let moveSequence = board.positions.map(p => (p.x * width + p.y).toString(36)).join('_');\n  qs.set('m', moveSequence);\n}\n\n//# sourceURL=webpack:///./src/index.js_+_3_modules?")}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var t=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](t,t.exports,__webpack_require__),t.exports}var __webpack_exports__=__webpack_require__(411)})();