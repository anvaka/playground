<!DOCTYPE html>
<meta name="robots" content="noindex">
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Perlin noise play</title>
</head>
<body>
<canvas id='scene'></canvas>
<script>
class Perlin {
  constructor() {
    this.gradients = {};
  }
  rand_vect(){
    let theta = Math.random() * 2 * Math.PI;
    return {x: Math.cos(theta), y: Math.sin(theta)};
  }
  dot_prod_grid(x, y, vx, vy) {
    let g_vect;
    let d_vect = {x: x - vx, y: y - vy};
    if (this.gradients[[vx,vy]]){
      g_vect = this.gradients[[vx,vy]];
    } else {
      g_vect = this.rand_vect();
      this.gradients[[vx, vy]] = g_vect;
    }
    return d_vect.x * g_vect.x + d_vect.y * g_vect.y;
  }
  smootherstep(x){
    return 6*x**5 - 15*x**4 + 10*x**3;
  }
  interp(x, a, b){
    return a + this.smootherstep(x) * (b-a);
  }
  
  get(x, y) {
    let xf = Math.floor(x);
    let yf = Math.floor(y);
    //interpolate
    let tl = this.dot_prod_grid(x, y, xf,   yf);
    let tr = this.dot_prod_grid(x, y, xf+1, yf);
    let bl = this.dot_prod_grid(x, y, xf,   yf+1);
    let br = this.dot_prod_grid(x, y, xf+1, yf+1);
    let xt = this.interp(x-xf, tl, tr);
    let xb = this.interp(x-xf, bl, br);
    let v = this.interp(y-yf, xt, xb);
    return v;
  }
} 


let cnv = document.querySelector('#scene');
let width = cnv.width = 480;
let height = cnv.height = 480;
let ctx = cnv.getContext('2d');
let p = new Perlin();

ctx.fillRect(0, 0, width, height);
let imgData = ctx.getImageData(0, 0, width, height);
let pixels = imgData.data;

for (let y = 0; y < height; ++y) {
  for (let x = 0; x < width; ++x) {
    let offset = (y * width + x) * 4;
    let c = (p.get(x/width, y/width) + 1)/2;
    pixels[offset] = Math.round(255*c);
    pixels[offset+1] = Math.round(c * 255);
  }
}

ctx.putImageData(imgData, 0, 0)


</script>
</body>
</html>